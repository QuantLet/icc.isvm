#' Run ISVM
#'
#' Run the ISVM algorithm
#'
#' @import xts
#' @import zoo
#' @import data.table
#' @import lubridate
#'
#' @param ICC_DT_full The output object generated by the function `run_experiment`.
#' @param DT_full A data.table with structure as provided in the example.
#' @param subset_maturities Boolean value. Should only a subset of the closest maturities be considered? Defaults to TRUE.
#' @param N_subs_date Number of dates to subset the input data from. Defaults to 5.
#' @param n_boottrial How many bootstrap iterations should be run? Defaults to 500.
#' @param select_bandwidth Boolean value. Should the optimal bandwidth for the local polynomial kernel regression be selected automatically? If TRUE, bandwidth will be selected according to least-squares cross-validation. Defaults to FALSE.
#' @param min_nrow Minimum observations required per cluster so that ISVM is calculated. Defaults to 25.
#' @param return_np_estimation_pars Should the fitted estimation parameters be returned? Defaults to `FALSE`.
#' @param return_lm Should the fitted object be returned? Defaults to `FALSE`.
#' @param return_lm_boot Should the bootstrap fitted object be returned? Only works if `return_lm = FALSE`. Defaults to `FALSE`.
#'
#' @return Returns a list with both the ICC and the ISVM result.

#' @export
run_ISVM <- function(ICC_DT_full,
                     DT_full,
                     subset_maturities = TRUE,
                     N_subs_date = 5,
                     n_boottrial = 500,
                     min_nrow = 25,
                     select_bandwidth = F,
                     return_np_estimation_pars = FALSE,
                     return_lm = FALSE,
                     return_lm_boot = FALSE){
  ICC_ISVM_list <- lapply(seq_along(ICC_DT_full), function(i){
    
    # in case the clustering was unsuccessful, abort #
    if (length(ICC_DT_full[[i]]) == 0)  {
      return(list("ICC" = ICC_DT_full[[i]], "ISVM" = list()))
    } else {
      states <- ICC_DT_full[[i]]$states
      sub_states_list <- get_sub_states(states)
      DT_subs <- copy(DT_full[timestamp %between% c(ICC_DT_full[[i]]$price_plot$data[,min(t) - 10],
                                                    ICC_DT_full[[i]]$price_plot$data[,max(t) + 10])])
      
      ## get dataset for clustering ##
      DT_subs_list <- make_subset2(DT_subs,
                                   start_date  = ICC_DT_full[[i]]$date - N_subs_date,
                                   end_date = ICC_DT_full[[i]]$date,
                                   subset_maturities = subset_maturities,
                                   min_maturity = 5,
                                   max_maturity = 60,
                                   money_range = c(0.8,1.2),
                                   impute = F,
                                   verbose = F)
      
      DT_subs_list$train_data[,state := states[seq(nrow(DT_subs_list$train_data)),state]]
      
      if (min(sapply(sub_states_list, function(x) nrow(DT_subs_list$train_data[state %in% x]))) < min_nrow) {
        
        print(paste("Fitting model for ", ICC_DT_full[[i]]$date))
        cat("\n")
        message(paste("Error: smallest cluster has less than", min_nrow, "observations and was discarded. Please adjust gamma."))
        cat("\n")
        return(list("ICC" = ICC_DT_full[[i]], "ISVM" = list()))
      } else {
        print(paste("Fitting model for ", ICC_DT_full[[i]]$date))
        ISVM_list <- lapply(sub_states_list,function(x)  {
          fit_sub_state_ISVM(DT_subs_list,
                             DT_subs,
                             states,
                             n_boottrial = n_boottrial,
                             verbose = F,
                             subs = N_subs_date,
                             threshold = 0,
                             impute = F,
                             state = x,
                             select_bandwidth = select_bandwidth,
                             return_np_estimation_pars = return_np_estimation_pars,
                             return_lm = return_lm,
                             return_lm_boot = return_lm_boot)
        })
        return(list("ICC" = ICC_DT_full[[i]], "ISVM" = ISVM_list))
      }
    }
  })
  return(ICC_ISVM_list)
}