#' Get ICC cluster.
#'
#' Computes clusters generated by ICC and returns a list with ICC output data & plots and saves the files if needed.
#' @import data.table
#' @import beepr
#' @import reticulate
#' @import ggplot2
#' @import scales
#'
#' @param DATA Output 'train_data' generated from "make_subset" function.
#' @param plot_data Output 'plot_data' generated from "make_subset" function.
#' @param N_subs_date Number of dates to subset the input data from.
#' @param K Integer value. Number of clusters. Defaults to 2.
#' @param gamma Numeric value for the switching penalty. Defaults to 0.
#' @param w_max Integer value. The number of maximum iterations for ICC. Defaults to 3.
#' @param money_range Vector with lower and upper limit of moneyness values to consider. The natural boundary would be c(0,Inf).
#' @param impute Boolean value. Should missing observations be imputed?
#' @param subset_maturities Boolean value. Should only a subset of the closest maturities be considered?
#' @param DEBUG Integer value. Parameter for verbosity of ICC algorithm that can be either 0 or 1. Defaults to 0.
#' @param random_seed Numeric value for reproducibility of ICC results. Defaults to 123.
#' @param make_beep Makes a beep when ICC calculation is finished. Defaults to FALSE.
#' @param save_plot Boolean. Should the plots be saved?
#' @param data_only Boolean. If set to TRUE, only the data is returned and plotting is skipped. Defaults to FALSE.
#' @param distance_function Character value. Which distance should be used? Choose either "euclidean","loglik" (loglikelihood), or "mahalanobis".
#' @param print_plot Boolean. Should the plots be saved?
#'
#' @return DATA: The input data.
#' @return date: The date of the last observation.
#' @return symbols: List of all symbols that were used for clustering.
#' @return price_plot: Plot of the clustered price of the underlying index.
#' @return vola_plot: Plot of the clustered input data.
#' @return states: Time series with the states at each point in time.
#' @return mean_impl_vola: Table with mean and sd of the detected clusters.
#' @return w_max: Number of maximum iterations specified.
#' @return w: Number of actual iterations.
#' @return K: The input number of clusters .
#' @return scale_gamma: Indicates if the penalty gamma got scaled down.
#' @return gamma_init: Initial value provided for gamma.
#' @return gamma_value: Actual value for gamma. In case gamma hasn't been scaled down this will be identical to 'gamma_init'.

#' @export
get_clusters <- function(DATA,
                         plot_data,
                         N_subs_date,
                         K = 2,
                         gamma = 0,
                         w_max = 3,
                         money_range,
                         impute,
                         subset_maturities,
                         DEBUG = 0,
                         random_seed = 123,
                         make_beep = F,
                         save_plot = T,
                         data_only = T,
                         distance_function = NA,
                         print_plot = TRUE){

  PLOT_DATA <- copy(plot_data)
  test_date <- DATA[,as.Date(max(t))]
  DT_vola_plot <- melt(DATA,id.vars = "t")
  test_symbols <- DT_vola_plot[,unique(variable)]
  plot_theme <- make_plot_theme()

  if (!exists("ICC")) {
    ## initiation file ##
    libraries_py <- list("pandas", "numpy", "scipy")
    ## ##

    ## create conda env ##
    if (!("r-conda-ICC" %in% reticulate::conda_list()$name)) {
      reticulate::conda_create("r-conda-ICC")
      reticulate::conda_install(envname = "r-conda-ICC", packages = libraries_py)
    }
    ## use env ##
    reticulate::use_condaenv("r-conda-ICC")

    ## load python functions ##
    reticulate::source_python("./python/MFCF_new/ICC.py")
    np <- reticulate::import("numpy", convert = FALSE)
    ## ##
  }

  if (is.na(distance_function)) {
    distance_function <- "loglik"
    cat("\n")
    writeLines(paste(" ",
                     paste(test_date,
                           "- Warning: no distance function provided, defaulted to 'loglik', please adjust if this is undesired"),
                     sep = "\n"))
    cat("\n")
  }

  DT_cal_ICC_np <- reticulate::np_array(as.matrix(DATA[,!c("t")]), dtype = np$float64)
  np_random_seed <- reticulate::np_array(random_seed, dtype = np$int64)
  K <- as.integer(K)

  # check if data is suitable for clustering (this is computationally expensive but makes sure we can continue)
  if (ICC(DT_cal_ICC_np, w_max = 1, gamma = 0, K = K, random_seed = np_random_seed)[[2]][[1]] == 0) {
    cat("\n")
    writeLines(paste(" ",
                     paste(test_date,
                           "- Error: no successful iteration on Gamma = 0. Choose a different data set."),
                     sep = "\n"))
    cat("\n")
    return(list())
  }

  ICC_res <- data.table(ICC(DT_cal_ICC_np,
                            K = K,
                            gamma = gamma,
                            w_max = w_max,
                            distance_function = distance_function,
                            DEBUG = DEBUG,
                            random_seed = np_random_seed))
  ## scale down gamma:
  scale_gamma <- FALSE
  discard_day <- FALSE
  gamma_init <- gamma

  if (ICC_res[[1]][[2]] == 0 || sum(ICC_res[[1]][[1]]) == 0) { ## assumption: there must be different states
    scale_gamma <- TRUE
    i_max <- 5
    ICC_list <- vector(mode = "list", length = 1)

    for (i in 1:i_max) {
      gamma_downscale <- gamma*0.75**i
      ICC_res <- data.table(ICC(DT_cal_ICC_np,
                                K = K,
                                gamma = gamma_downscale,
                                w_max = w_max,
                                distance_function = distance_function,
                                DEBUG = DEBUG,
                                random_seed = np_random_seed))

      if (ICC_res[[1]][[2]] > 0 & sum(ICC_res[[1]][[1]]) > 0) {
        ICC_list[[1]] <- ICC_res
        break
      }
      if (i == i_max) {
        cat("\n")
        writeLines(paste(" ",
                         paste(test_date, "Error: no successful iteration. Consider choosing smaller value."),
                         "Gamma could not be scaled down",
                         sep = "\n"))
        cat("\n")
        discard_day <- TRUE
      }

    }
    if (discard_day) return(list())
    cat("\n")
    writeLines(paste(" ",
                     paste(test_date,
                           "Gamma scaled down to",round(gamma_downscale,2), "after", i, "iterations"),
                     sep = "\n"))
    cat("\n")
    gamma <- gamma_downscale
    rm(gamma_downscale)
    ICC_res <- ICC_list[[1]]
  }
  w <- ICC_res[[1]][[2]]

  if (make_beep) beep() # this makes a sound when the calculation is done (need only for big data)

  DT_ICC_res <- data.table(DATA[,"t"], "state" = ICC_res[[1]][[1]])

  # add the calculated states to the training dataset and set it as a factor for plotting
  PLOT_DATA[DT_ICC_res, state := i.state, on = "t"]

  # calculate which is the high and which is the low mean state
  DT_vola_plot[DT_ICC_res, state := i.state, on = "t"]

  # get mean of different regimes
  mean_impl_vola <- DT_vola_plot[,list(mean = mean(value), sd = sd(value)),by = state]

  if (K == 2) {
    high_state <- mean_impl_vola[mean_impl_vola[,which.max(mean)],state]
    low_state <- mean_impl_vola[mean_impl_vola[,which.min(mean)], state]

    # do the same for DT_ICC_res
    make_high_low_state(DT_vola_plot, low_state, high_state)
    make_high_low_state(DT_ICC_res, low_state, high_state)
    make_high_low_state(PLOT_DATA, low_state, high_state)
    make_high_low_state(mean_impl_vola, low_state, high_state)
  }
  if (data_only == T) {
    result <- list("input_data" = DATA,
                   "date" = test_date,
                   "states" = DT_ICC_res,
                   "mean_impl_vola" = mean_impl_vola,
                   "w_max" = w_max,
                   "w" = w,
                   "K" = K,
                   "gamma_init" = gamma_init,
                   "scale_gamma" = scale_gamma,
                   "gamma_value" = round(gamma,2))
    return(result)
  }

  # generate a price plot where the color of the observations is determined by the state in the aesthetics (aes) part
  ICC_plot_price <- ggplot(PLOT_DATA, aes(x = t, y = close, color = state, group = state)) +
    geom_point() + # do a scatterplot, e.g. geom_line() would make it a lineplot
    labs(x = "Date", y = "BTC / USD", title = paste("Gamma = ",round(gamma,2))) + # rename axis labels and title
    plot_theme + # add the customized plot theme that makes the background transparent and removes the gridlines
    coord_cartesian(xlim = c(min(PLOT_DATA[,t]) - 3600*6,max(PLOT_DATA[,t]) + 3600*6))

  # generate a volatility plot where the color of the observations is determined by the state in the aesthetics (aes) part
  ICC_plot_vola <- ggplot(DT_vola_plot, aes(x = t, y = value, group = variable, color = state)) +
    geom_line() +
    labs(x = "Date", y = "Implied Volatility", title = paste("Gamma = ",round(gamma,2))) + # rename axis labels and title
    coord_cartesian(xlim = c(min(PLOT_DATA[,t]) - 3600*6,max(PLOT_DATA[,t]) + 3600*6)) +
    plot_theme

  if (save_plot) {

    # make sure the directories for saving the plots are existing
    make_plot_directory()
    dir_names <- make_experiment_directory(N_subs_date = N_subs_date,
                                           K = K,
                                           gamma = gamma_init,
                                           impute = impute,
                                           money_range = money_range,
                                           subset_maturities = subset_maturities)

    # create a filename for the experiment with the gamma value, number of iterations and distance function
    file_name_price <- paste(dir_names$dir_name_price,
                             test_date, "_ICC_",
                             w, "w_",
                             gsub("\\.", "_", gamma_init), "gamma_",
                             distance_function, "dist_price.png", sep = "")

    file_name_vola <- paste(dir_names$dir_name_vola,
                            test_date, "_ICC_",
                            w, "w_",
                            gsub("\\.", "_", gamma_init), "gamma_",
                            distance_function, "dist_vola.png", sep = "")
    # save the plot
    ggsave(plot = ICC_plot_price, file = file_name_price, bg = "transparent",
           width = 11.69, height = 8.27, dpi = 300)
    ggsave(plot = ICC_plot_vola, file = file_name_vola,  bg = "transparent",
           width = 11.69, height = 8.27, dpi = 300)
  }

  result <- list("input_data" = DATA,
                 "date" = test_date,
                 "symbols" = test_symbols,
                 "price_plot" = ICC_plot_price,
                 "vola_plot" = ICC_plot_vola,
                 "states" = DT_ICC_res,
                 "mean_impl_vola" = mean_impl_vola,
                 "w_max" = w_max,
                 "w" = w,
                 "K" = K,
                 "scale_gamma" = scale_gamma,
                 "gamma_init" = gamma_init,
                 "gamma_value" = gamma)

  if (print_plot) {
    # show the plots
    print(result$price_plot)
    print(result$vola_plot)
  }
  return(result)
}
